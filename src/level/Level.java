package level;

import java.util.LinkedList;
import java.util.ArrayList;
import java.util.ListIterator;
import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;

import util.*;

public class Level
{
	private File filePath = null;

	private LinkedList<LevelLayer> layers;
	private LinkedList<GameObject> objects;
	private Collision collision;

	public Level(int sizeX, int sizeY) throws IOException
	{
		layers = new LinkedList<LevelLayer>();
		objects = new LinkedList<GameObject>();
		LevelLayer curElem = null;
		collision = new Collision("default.col", 256);

		for (int i = 0; i < 3; i++)
		{
			curElem = new LevelLayer();
			layers.push(curElem);
			curElem.load(i);
			curElem.load(Data.getDataDirectory() + "/data/gfx/layer0.bmp", 16, 16, 16, 256);
			curElem.populate(sizeX, sizeY, 0);
			System.out.printf("New layer: %d\n", curElem.getId());
		}
	}

	public Level(File fileName) throws IOException
	{
		layers = new LinkedList<LevelLayer>();
		objects = new LinkedList<GameObject>();
		this.filePath = fileName;
		System.out.printf("Path is: %s\n", this.filePath);
		load(filePath);
	}

	public File getFilePath()
	{
		return this.filePath;
	}

	public void setFilePath(File path)
	{
		this.filePath = path;
	}

	public int getNumOfLayers()
	{
		return this.layers.size();
	}

	public LevelLayer getLayer(int num)
	{
		return this.layers.get(num);
	}

	public LinkedList<GameObject> getObjectList()
	{
		return this.objects;
	}

	public int getCollision(int tile)
	{
		return this.collision.getCollision(tile);
	}

	public void reloadCollision() throws IOException
	{
		collision = new Collision("default.col", 256);
	}

	private void load(File fileName) throws IOException
	{
		FileRead fp = new FileRead(fileName);

		if (fp != null)
		{
			LevelLayer curElem = null;

			while (fp.hasNext())
			{
				switch (fp.getNext())
				{
					case "COLLISION":
						collision = new Collision(fp.getNext(), Integer.parseInt(fp.getNext()));
					break;
					case "LAYER":
						curElem = new LevelLayer();
						layers.push(curElem);
						curElem.load(Integer.parseInt(fp.getNext()));
					break;
					case "IMG":
						curElem.load(Data.getDataDirectory() + "/data/gfx/" + fp.getNext(), Integer.parseInt(fp.getNext()), Integer.parseInt(fp.getNext()), Integer.parseInt(fp.getNext()), Integer.parseInt(fp.getNext()));
						curElem.load(fp); // load the tileset
					break;
					case "OBJECTS":
						loadObjects(fp);
					break;

					default:
					break;
				}
			}

			if (layers.size() == 0)
			{
				throw new IOException("No level layers found in:\n"+fileName+"\nPerhaps it is not a valid level file?");
			}
		}

		fp.close();
	}

	private void loadObjects(FileRead fp)
	{
		String line;
		String [] words;
		int token;
		GameObject curObj;

		while (fp.hasNext())
		{
			line = fp.getLine();
			words = line.split("\\s");
			token = -1;

			if (words[0].equals("END"))
				return;

			if (words.length >= 4 && !(words[0].equals("END")))
			{
				objects.push(new GameObject());
				curObj = objects.getFirst();
				curObj.setName(words[0]);
				curObj.setX(Integer.parseInt(words[1]));
				curObj.setY(Integer.parseInt(words[2]));
				curObj.setDirection(Integer.parseInt(words[3]) != 0);

				System.out.printf("Adding: %s, (%s,%s) dir: %s\n", words[0], words[1], words[2], words[3]);
			}
		}
	}

	public void write(File fileName)
	{
		FileWrite fp = new FileWrite(fileName);

		if (fp != null)
		{
			StringBuilder levelContent = new StringBuilder();

			levelContent.append("# File autogenerated with Editor. Do not modify.\n\n");
			levelContent.append("COLLISION default.col 256\n\n"); // temp

			// In this algorithm I make an assumption that sequentially accessing elements in an array
			// is faster than calling getTile() method of an ArrayList object to retreive the elements.
			for (int i = layers.size(); i > 0; i--)
			{
				LevelLayer curElem = layers.get(i - 1);
				String imgPath = curElem.getImgPath();
				String [] words = imgPath.split("/");
				int levelWidth = curElem.getWidth();
				int levelHeight = curElem.getHeight();

				ArrayList<ArrayList<Integer>> list = curElem.getList();
				Integer [][] array = new Integer[list.size()][];

				for (int n = 0; n < list.size(); n++)
				{
					array[n] = list.get(n).toArray(new Integer[0]);
				}

				System.out.printf("Converted\n");

				levelContent.append("LAYER " + curElem.getId() + "\n");
				levelContent.append("IMG " + words[words.length - 1] + " " + curElem.getTileW() + " " + curElem.getTileH() + " " + curElem.getImgRowW() + " " + curElem.getImgSize() + "\n");

				for (int y = 0; y < levelHeight; y++)
				{
					for (int x = 0; x < levelWidth; x++)
					{
						levelContent.append(Integer.toString(array[y][x]));

						if (x < levelWidth - 1)
						{
							levelContent.append("\t");
						}
					}
					levelContent.append("\n");
				}

				// Old method
//				for (int y = 0; y < levelHeight; y++)
//				{
//					for (int x = 0; x < levelWidth; x++)
//					{
//						levelContent.append(curElem.getTile(x, y)); // this is resource wastful

//						if (x < levelWidth - 1)
//						{
//							levelContent.append("\t");
//						}
//					}

//					levelContent.append("\n";
//				}

				levelContent.append("END\n\n");
			}

			levelContent.append("OBJECTS\n");
			for (GameObject curObj : this.objects)
			{
				levelContent.append(curObj.getName() + "\t" + curObj.getX() + "\t" + curObj.getY() + "\t" + (curObj.getDirection() ? 1 : 0) + "\n");
			}
//			levelContent.append("player\t32\t48\t1\n"); // temp
			levelContent.append("END\n");

			System.out.printf("Writing to file\n");
			fp.writeLine(levelContent.toString());
		}

		fp.close();
	}

	public void resize(int leftX, int rightX, int topY, int bottomY, int tile)
	{
		for (int i = 0; i < layers.size(); i++)
		{
			// expand
			if (leftX > 0)
				layers.get(i).expandLeft(leftX, 0);
			if (rightX > 0)
				layers.get(i).expandRight(rightX, 0);
			if (topY > 0)
				layers.get(i).expandTop(topY, 0);
			if (bottomY > 0)
				layers.get(i).expandBottom(bottomY, 0);
			// reduce
			if (leftX < 0)
				layers.get(i).reduceLeft(-leftX);
			if (rightX < 0)
				layers.get(i).reduceRight(-rightX);
			if (topY < 0)
				layers.get(i).reduceTop(-topY);
			if (bottomY < 0)
				layers.get(i).reduceBottom(-bottomY);
		}
	}
}
